@page "/routetracking"

@using CommunityToolkit.Maui.Alerts;
@using MauiBlazor.Entities;
@using MauiBlazor.Helpers;
@using MauiBlazor.Interfaces;
@using Blazorise;
@using MauiBlazor.Models;
@using MauiBlazor.Views;
@using Microsoft.Extensions.Logging;
@using System.Diagnostics;
@using System.Collections.ObjectModel;
@using static MauiBlazor.Helpers.ExecutionHelper;

@inject IRouteTrackingPageService RouteTrackingPageService;
@inject ILogger<RouteTrackingPage> Logger

<h1>Route</h1>
<br />

<Div Style="font-size: 0.65rem">
    <Table Striped>
        <TableHeader ThemeContrast="ThemeContrast.Dark" Style="font-size: 0.9rem">
            <TableRow>
                <TableHeaderCell>#</TableHeaderCell>
                <TableHeaderCell>Coord.</TableHeaderCell>
                <TableHeaderCell>Time</TableHeaderCell>
                <TableHeaderCell>Abs.</TableHeaderCell>
                <TableHeaderCell>Rel.</TableHeaderCell>
            </TableRow>
        </TableHeader>

        <TableBody>
            @for (int i = 0; i < _routeLocations.Count; i++)
            {
                var number = i + 1;
                var location = _routeLocations[i];
                <TableRow Clicked="@(() => OnLocationClickedAsync(location.RouteLocation))">
                    <TableRowHeader>@number</TableRowHeader>
                    <TableRowCell>@location.Coordinates</TableRowCell>
                    <TableRowCell>@location.CreationDate</TableRowCell>
                    <TableRowCell>@location.AbsoluteDuration</TableRowCell>
                    <TableRowCell>@location.RelativeDuration</TableRowCell>
                </TableRow>
            }
        </TableBody>
    </Table>
</Div>
<Div>
    <Button Color="Color.Primary" Clicked="@OnAddLocationAsync" Disabled="@IsAuto">Add Location</Button>
    <Button Color="Color.Primary" Clicked="@OnShowRouteAsync" Disabled="@(!HasRoute || IsAuto)">Show Route</Button>
    <Button Color="Color.Primary" Clicked="@OnResetAsync" Disabled="@IsAuto">Reset</Button>
</Div>
<Div Class="mt-1">
    <Button Color="Color.Primary" Clicked="@OnStartAutoAsync" Disabled="@IsAuto">Start Auto</Button>
    <Button Color="Color.Primary" Clicked="@OnStopAutoAsync" Disabled="@(!IsAuto)">Stop Auto</Button>
</Div>
<br />

@code {
    private ObservableCollection<RouteLocationViewModel> _routeLocations = new ObservableCollection<RouteLocationViewModel>();
    private IDispatcherTimer? _timer;

    private bool HasRoute => _routeLocations.Any();
    private bool IsAuto => _timer is not null;

    protected async override Task OnInitializedAsync() => await ExecuteErrorHandledAsync(async () => await FetchLocationsAsync(), Logger);

    private async Task OnAddLocationAsync() => await ExecuteErrorHandledAsync(async () => await AddLocationAsync(true), Logger);

    private async Task OnLocationClickedAsync(RouteLocation routeLocation) => await ExecuteErrorHandledAsync(async () => await Application.Current.MainPage.Navigation.PushAsync(new MapPage(routeLocation)), Logger);

    private async Task OnShowRouteAsync() => await ExecuteErrorHandledAsync(async () =>
    {
        if (!HasRoute) return;

        await Application.Current.MainPage.Navigation.PushAsync(new MapPage(_routeLocations.Select(l => l.RouteLocation).ToList()));
    });

    private async Task OnResetAsync() => await ExecuteErrorHandledAsync(async () =>
                                            {
                                                await RouteTrackingPageService.DeleteLocationsAsync();
                                                await FetchLocationsAsync();
                                                await NotificationHelper.ShowSnackMessage("Locations removed");
                                            }, Logger);

    private async Task OnStartAutoAsync()
    {
        _timer = Application.Current.Dispatcher.CreateTimer();
        _timer.Interval = TimeSpan.FromMinutes(1);
        _timer.Tick += async (s, e) => await AddAutoLocationAsync();
        _timer.Start();
    }

    private async Task OnStopAutoAsync()
    {
        _timer?.Stop();
        _timer = null;
    }

    private async Task FetchLocationsAsync() => await ExecuteErrorHandledAsync(async () =>
                                                     {
                                                         var locations = await RouteTrackingPageService.GetLocationsAsync();
                                                         _routeLocations.Clear();
                                                         foreach (var location in GetLocationViewModels(locations))
                                                         {
                                                             _routeLocations.Add(location);
                                                         }
                                                     }, Logger);

    private async Task AddLocationAsync(bool showSnack)
    {
        var location = await LocationHelper.GetLocationAsync();
        if (location is null) return;

        await RouteTrackingPageService.SaveLocationAsync(location);
        await FetchLocationsAsync();
        if (showSnack)
        {
            await NotificationHelper.ShowSnackMessage("Location added");
        }
    }

    private async Task AddAutoLocationAsync() => await ExecuteErrorHandledAsync(async () => await AddLocationAsync(false), Logger);

    private IEnumerable<RouteLocationViewModel> GetLocationViewModels(ICollection<RouteLocation> locations)
    {
        if (!locations.Any()) return Enumerable.Empty<RouteLocationViewModel>();

        var ordered = locations.OrderBy(l => l.CreationDate).ToList();
        var startTime = ordered.First().CreationDate;

        return ordered.Select((routeLocation, i) =>
        {
            var absoluteTime = routeLocation.CreationDate - startTime;
            var relativeTime = i == 0 ? TimeSpan.Zero : routeLocation.CreationDate - ordered[i - 1].CreationDate;

            return new RouteLocationViewModel(routeLocation, absoluteTime, relativeTime);
        });
    }
}